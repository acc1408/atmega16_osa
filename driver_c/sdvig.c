#ifndef SDVIG_C
#define SDVIG_C
#include <driver_h/sdvig.h>
//***********************************************************************
//		Фунции для работы со сдвигом с сохраненим знака					*
//----------------------------------------------------------------------*
// сдвиг со сохранением знака для 1 байта
// байт для сдвига с сохранением знака, кол-во сдвигов

int8_t sdvig8(int8_t ch, uint8_t kol)
{
uint8_t ret;
asm volatile(
		"WHILE_%=:"			"\n\t" // метка повторную проверку
		"cpi %[KOL],0" 		"\n\t" // сравнение с 0
		"breq EXIT_%=" 		"\n\t" // если сделаны все необходимые сдвиги то выходим из цикла
		"asr %[CH]" 		"\n\t" // сдвигаем страший байт
		"dec %[KOL] "		"\n\t" // декреминуем кол-во сдвигов
		"rjmp WHILE_%="		"\n\t" // возврат цикла
		"EXIT_%=:" 			 "\n\t"
		"mov %[RET],%[CH]" "\n\t"
		:[RET]"=&r"(ret)
		:[CH]"r"(ch), [KOL] "r"(kol)
		);
return ret;
}

//-------------------------------------------------------------------------
// сдвиг со сохранением знака для 2 байт
// байт для сдвига с сохранением знака, кол-во сдвигов
int16_t sdvig16(int16_t ch, uint8_t kol)
{
int16_t ret;
asm volatile (
	"WHILE_%=:"			"\n\t" // метка повторную проверку
	"cpi %[KOL],0" 		"\n\t" // сравнение с 0
	"breq EXIT_%=" 		"\n\t" // если сделаны все необходимые сдвиги то выходим из цикла
	"asr %B[CH]" 		"\n\t" // сдвигаем страший байт
	"ror %A[CH]" 		"\n\t" // сдвигаем младший батй
	"dec %[KOL] "		"\n\t" // декреминуем кол-во сдвигов
	"rjmp WHILE_%="		"\n\t" // возврат цикла
	"EXIT_%=:" 			 "\n\t"
	"mov %A[RET],%A[CH]" "\n\t"
	"mov %B[RET],%B[CH]" "\n\t"
	:[RET]"=&r"(ret)
	:[CH]"r"(ch), [KOL] "r"(kol)
	);
return ret;
}
//***********************************************************************************
#endif
